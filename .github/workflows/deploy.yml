name: Deploy to production server
run-name: Deploying ${{ github.sha }} to production server

on:
  push:
    branches: [main]
  workflow_dispatch: # Allow manual trigger

env:
  # Application
  APP_NAME: ${{ vars.APP_NAME || 'app' }}
  # Frontend
  FRONTEND_IMAGE: frontend-image
  FRONTEND_CONTAINER: ${{ vars.APP_NAME || 'app' }}-frontend
  FRONTEND_PORT: ${{ vars.FRONTEND_PORT || ''}}
  # Backend
  BACKEND_IMAGE: backend-image
  BACKEND_CONTAINER: ${{ vars.APP_NAME || 'app' }}-backend
  BACKEND_PORT: ${{ vars.BACKEND_PORT || ''}}
  # Database
  DATABASE_IMAGE: database-image
  DATABASE_CONTAINER: ${{ vars.APP_NAME || 'app' }}-database
  DATABASE_PORT: ${{ vars.DATABASE_PORT || '' }}
  DATABASE_NAME: ${{ vars.APP_NAME || 'app' }}-db
  DATABASE_USER: ${{ vars.APP_NAME || 'app' }}-user
  DATABASE_PASSWORD: ${{ secrets.DATABASE_PASSWORD || '' }}
  DATABASE_VOLUME: ${{ vars.APP_NAME || 'app' }}-database-volume
  # Server info
  SERVER_HOST: ${{ secrets.SERVER_HOST }}
  SERVER_USER: ${{ secrets.SERVER_USER }}
  SERVER_KEY: ${{ secrets.SERVER_KEY }}
  # Environment
  NODE_ENV: production

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker images
        run: |
          IMAGES_TO_SAVE=""
          
          # Build frontend if directory exists and port is configured
          if [ -d "./packages/frontend" ] && [ ! -z "${{ env.FRONTEND_PORT }}" ]; then
            echo "Building frontend image..."
            docker build -t ${{ env.FRONTEND_IMAGE }}:${{ github.sha }} ./packages/frontend
            docker tag ${{ env.FRONTEND_IMAGE }}:${{ github.sha }} ${{ env.FRONTEND_IMAGE }}:latest
            IMAGES_TO_SAVE="$IMAGES_TO_SAVE ${{ env.FRONTEND_IMAGE }}:latest"
          fi
          
          # Build backend if directory exists and port is configured
          if [ -d "./packages/backend" ] && [ ! -z "${{ env.BACKEND_PORT }}" ]; then
            echo "Building backend image..."
            docker build -t ${{ env.BACKEND_IMAGE }}:${{ github.sha }} ./packages/backend
            docker tag ${{ env.BACKEND_IMAGE }}:${{ github.sha }} ${{ env.BACKEND_IMAGE }}:latest
            IMAGES_TO_SAVE="$IMAGES_TO_SAVE ${{ env.BACKEND_IMAGE }}:latest"
          fi
          
          # Save all built images
          if [ ! -z "$IMAGES_TO_SAVE" ]; then
            docker save $IMAGES_TO_SAVE | gzip > app-images.tar.gz
          else
            echo "No images to build - creating empty archive"
            tar -czf app-images.tar.gz --files-from /dev/null
          fi
          
      - name: Copy files to prod server
        uses: appleboy/scp-action@v0.1.4
        with:
          host: ${{ env.SERVER_HOST }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_KEY }}
          port: 22
          source: "app-images.tar.gz,docker-compose.yml"
          target: "/opt/${{ env.APP_NAME }}/"

      - name: Deploy on prod server
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ env.SERVER_HOST }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_KEY }}
          port: 22
          script: |
            cd /opt/${{ env.APP_NAME }}
            
            # Load images if any were built
            if [ -s app-images.tar.gz ]; then
              docker load < app-images.tar.gz
            fi
            
            # Stop existing containers
            docker-compose down || true
            
            # Start all services defined in docker-compose.yml
            docker-compose up -d
            
            # Clean up old images
            docker image prune -f
            for image in ${{ env.FRONTEND_IMAGE }} ${{ env.BACKEND_IMAGE }}; do
              if docker images $image -q 2>/dev/null | head -n 1; then
                docker images $image --format "table {{.Repository}}\t{{.Tag}}\t{{.ID}}" | tail -n +4 | awk '{print $3}' | head -n -3 | xargs -r docker rmi 2>/dev/null || true
              fi
            done
            
            # Clean up deployment files
            rm -f app-images.tar.gz

      - name: Verify deployment
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ env.SERVER_HOST }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_KEY }}
          port: 22
          script: |
            cd /opt/${{ env.APP_NAME }}
            
            # Check if frontend container is running (if configured)
            if [ ! -z "${{ env.FRONTEND_PORT }}" ]; then
              if docker ps | grep -q ${{ env.FRONTEND_CONTAINER }}; then
                echo "Frontend container is running successfully"
                
                # Test HTTP response
                sleep 10
                if curl -f http://localhost:${{ env.FRONTEND_PORT }} > /dev/null 2>&1; then
                  echo "Frontend is responding on port ${{ env.FRONTEND_PORT }}"
                else
                  echo "Frontend is not responding on port ${{ env.FRONTEND_PORT }}"
                fi
              else
                echo "Frontend container failed to start"
                docker ps -a | grep ${{ env.FRONTEND_CONTAINER }}
                exit 1
              fi
            fi
            
            # Check if backend container is running (if configured)
            if [ ! -z "${{ env.BACKEND_PORT }}" ]; then
              if docker ps | grep -q ${{ env.BACKEND_CONTAINER }}; then
                echo "Backend container is running successfully"
                
                # Test backend HTTP response (basic connectivity)
                sleep 5
                if curl -f http://localhost:${{ env.BACKEND_PORT }} > /dev/null 2>&1; then
                  echo "Backend is responding on port ${{ env.BACKEND_PORT }}"
                else
                  echo "Backend is not responding on port ${{ env.BACKEND_PORT }} (may be normal if no health endpoint)"
                fi
              else
                echo "Backend container failed to start"
                docker ps -a | grep ${{ env.BACKEND_CONTAINER }}
                exit 1
              fi
            fi
            
            # Check if database container is running (if configured)
            if [ ! -z "${{ env.DATABASE_PORT }}" ]; then
              if docker ps | grep -q ${{ env.DATABASE_CONTAINER }}; then
                echo "Database container is running successfully"
              else
                echo "Database container failed to start"
                docker ps -a | grep ${{ env.DATABASE_CONTAINER }}
                exit 1
              fi
            fi
            
            echo "Deployment verification complete"